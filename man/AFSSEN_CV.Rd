% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AFSSEN_CV.R
\name{AFSSEN_CV}
\alias{AFSSEN_CV}
\title{AFSSEN_CV}
\usage{
AFSSEN_CV(type_kernel = "exponential", param_kernel = 8, thres,
  number_non_zeros, ratio_lambda_H, number_lambda_H, num_lambda_H_NONad,
  lambda_H, lambda_K, early_CV, early_CV_thres, max_ite_nadp, max_ite_adp,
  max_ite_final, target_inc, proportion_training_set = 0.75,
  verbose = FALSE, fold_ad = 10, N = 500, I = 1000, I0 = 10,
  nu_beta = 2.5, range = 1/4, variance = 1, nu_eps = 1.5,
  range_eps = 1/4)
}
\arguments{
\item{type_kernel}{string. three possible choices are implemented.  \code{gaussian},
Defualt is \code{"exponential"}.
\code{exponential}, \code{sobolev}.}

\item{param_kernel}{scalar. Value of the characteristic smoothing parameter of the kernel.
It is the \eqn{\sigma} parameter of the Gaussian and the Exponential kernel, as introduced
 in \link[kernlab]{rbfdot} and \link[kernlab]{laplacedot} functions;
 the \eqn{\sigma} parameter of  the Sobolev.
Defualt is \code{8}.}

\item{thres}{scalar. Stopping criteria: beta increment threshold
\deqn{
|| \beta^{T} - \beta^(T-1) ||_{H} < thres
}
Defualt is \code{0.02}.}

\item{number_non_zeros}{scalar. Stopping Criteria: Kill switch; number of nonzero predictors
Defualt is \code{20}.}

\item{ratio_lambda_H}{scalar. \eqn{\lambda_{Hmax}/\lambda_{Hmin}}
Defualt is \code{0.01}.}

\item{number_lambda_H}{scalar. Generate the number of log-equally spaced \eqn{\lambda_{H}} in \eqn{[\lambda_{Hmin},\lambda_{Hmax}]}.
Defualt is \code{100}.}

\item{num_lambda_H_NONad}{scalar. Number of \eqn{\lambda_H} in non-adaptive step
Defualt is \code{50}.}

\item{lambda_H}{vector. You have option to insert directly a vector of \eqn{\lambda_H}.
Defualt is \code{numeric()}.}

\item{lambda_K}{vector. Vector of \eqn{\lambda_{K}}.}

\item{early_CV}{binary. 0 or 1 : applying the \code{early_CV_thres} stopping criteria or not.
Defualt is \code{0}.}

\item{early_CV_thres}{scalar. Stopping Criteria: Breaking point in CV plot.
\deqn{
|CV(h-1,k)-CV(h,k)| / |CV(h-1,k)| < early_CV_thres
}
Defualt is \code{0.001}.}

\item{max_ite_nadp}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in non-adaptive step
Defualt is \code{10}.}

\item{max_ite_adp}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in adaptive step
Defualt is \code{30}.}

\item{max_ite_final}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in final step
Defualt is \code{50}.}

\item{target_inc}{binary. Stopping Criteria: 0 or 1 : if target function is increased, stop
Defualt is \code{1}.}

\item{proportion_training_set}{scalar. value in (0,1), the
proportion for the training set for the Cross Validation in non-adaptive step
Defualt is \code{0.75}.}

\item{fold_ad}{scalar. Number of fold for using CV in adaptive steps to find optimum \eqn{\lambda_{H}} and \eqn{\lambda_{K}} and then the coefficients estimation.
Defualt is \code{10}.}
}
\value{
list containing:
 \itemize{
 \item \code{beta : } matrix. final estimation of coefficients.
 \item \code{beta_no_adaptive : }  matrix. estimation of coefficients after non-adaptive step.
 \item \code{predictors : } vector. final significant predictors.
 \item \code{predictors_no_adaptive : } vector. significant predictors after non-adaptive step.
 \item \code{lambda_H_opt : } scalar. optimum \eqn{\lambda_{H}}
 \item \code{lambda_K_opt : } scalar. optimum \eqn{\lambda_{K}}
 \item \code{pred_error : } scalar. prediction error
 \item \code{pred_error_der : } scalar. prediction error derivative.
 }
}
\description{
For a simulation data, with computing the optimum penalty parameters, It computes important variables and produce smooth estimates of their parameters in a function-on-scalar linear model
with sub-Gaussian errors and high-dimensional predictors.
}
\examples{
\dontrun{
data(simulation)
data(SobolevKernel)
time <- proc.time()
FLAME_estimation <- FLAME()
duration <- proc.time()-time
duration
names(FLAME_estimation)
}

}
