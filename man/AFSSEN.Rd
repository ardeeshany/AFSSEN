% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AFSSEN.R
\name{AFSSEN}
\alias{AFSSEN}
\title{AFSSEN}
\usage{
AFSSEN(X, Y, T_domain = seq(0, 1, length = 50),
  type_kernel = "exponential", param_kernel = 8, thres = 0.02,
  number_non_zeros = 20, ratio_lambda_H = 0.01,
  number_lambda_H = 100, num_lambda_H_NONad = 50,
  lambda_H = numeric(), lambda_K, early_CV = 0,
  early_CV_thres = 0.001, max_ite_nadp = 10, max_ite_adp = 30,
  max_ite_final = 50, target_inc = 1, proportion_training_set = 0.75,
  verbose = FALSE, fold_ad = 10)
}
\arguments{
\item{X}{matrix. \code{N} by \code{I} design matrix. It has
standardized columns.}

\item{Y}{matrix. \code{N} by \code{m} matrix of pointwise observations.}

\item{T_domain}{vector. Time domain for evaluation of \code{Y} and generating kernel.
Default is \code{T_domain = seq(0,1,m=50)}}

\item{type_kernel}{string. three possible choices are implemented.  \code{gaussian},
Defualt is \code{"exponential"}.
\code{exponential}, \code{sobolev}.}

\item{param_kernel}{scalar. Value of the characteristic smoothing parameter of the kernel.
It is the \eqn{\sigma} parameter of the Gaussian and the Exponential kernel, as introduced
 in \link[kernlab]{rbfdot} and \link[kernlab]{laplacedot} functions;
 the \eqn{\sigma} parameter of  the Sobolev.
Defualt is \code{8}.}

\item{thres}{scalar. Stopping criteria: beta increment threshold
\deqn{
|| \beta^{T} - \beta^(T-1) ||_{H} < thres
}
Defualt is \code{0.02}.}

\item{number_non_zeros}{scalar. Stopping Criteria: Kill switch; number of nonzero predictors
Defualt is \code{20}.}

\item{ratio_lambda_H}{scalar. \eqn{\lambda_{Hmax}/\lambda_{Hmin}}
Defualt is \code{0.01}.}

\item{number_lambda_H}{scalar. Generate the number of log-equally spaced \eqn{\lambda_{H}} in \eqn{[\lambda_{Hmin},\lambda_{Hmax}]}.
Defualt is \code{100}.}

\item{num_lambda_H_NONad}{scalar. Number of \eqn{\lambda_H} in non-adaptive step
Defualt is \code{50}.}

\item{lambda_H}{vector. You have option to insert directly a vector of \eqn{\lambda_H}.
Defualt is \code{numeric()}.}

\item{lambda_K}{vector. Vector of \eqn{\lambda_{K}}.}

\item{early_CV}{binary. 0 or 1 : applying the \code{early_CV_thres} stopping criteria or not.
Defualt is \code{0}.}

\item{early_CV_thres}{scalar. Stopping Criteria: Breaking point in CV plot.
\deqn{
|CV(h-1,k)-CV(h,k)| / |CV(h-1,k)| < early_CV_thres
}
Defualt is \code{0.001}.}

\item{max_ite_nadp}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in non-adaptive step
Defualt is \code{10}.}

\item{max_ite_adp}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in adaptive step
Defualt is \code{30}.}

\item{max_ite_final}{scalar. Stopping Criteria: Maximum iteration of coordinate descent algorithm in final step
Defualt is \code{50}.}

\item{target_inc}{binary. Stopping Criteria: 0 or 1 : if target function is increased, stop
Defualt is \code{1}.}

\item{proportion_training_set}{scalar. value in (0,1), the
proportion for the training set for the Cross Validation in non-adaptive step
Defualt is \code{0.75}.}

\item{fold_ad}{scalar. Number of fold for using CV in adaptive steps to find optimum \eqn{\lambda_{H}} and \eqn{\lambda_{K}} and then the coefficients estimation.
Defualt is \code{10}.}
}
\value{
list containing:
 \itemize{
 \item \code{beta : } matrix. final estimation of coefficients.
 \item \code{beta_no_adaptive : }  matrix. estimation of coefficients after non-adaptive step.
 \item \code{predictors : } vector. final significant predictors.
 \item \code{predictors_no_adaptive : } vector. significant predictors after non-adaptive step.
 \item \code{lambda_H_opt : } scalar. optimum \eqn{\lambda_{H}}
 \item \code{lambda_K_opt : } scalar. optimum \eqn{\lambda_{K}}
 }
}
\description{
It computes important variables and produce smooth estimates of their parameters in a function-on-scalar linear model
with sub-Gaussian errors and high-dimensional predictors.
}
\examples{
\dontrun{
data(simulation)
data(SobolevKernel)
time <- proc.time()
FLAME_estimation <- FLAME()
duration <- proc.time()-time
duration
names(FLAME_estimation)
}

}
